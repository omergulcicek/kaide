---
description: "USE WHEN: Server state, query/mutation hook veya query key factory yazıyorsan."
globs: "src/features/**/api/*.{ts,tsx},src/features/**/hooks/*.{ts,tsx},src/providers/query-provider.tsx"
alwaysApply: false
---

# TanStack Query

**Boundary:** Bileşen içinde HTTP/data fetching yasak. Veri sadece `hooks/` custom query hook’ları ile.

Ref: .cursor/rules/frontend/api.mdc (HTTP/data fetching yasağı SSOT), docs/architecture-guide.md (policy SSOT)

## Kısıtlamalar (Constraints)

- **API layer:** Bileşenler sadece hook ile veri; API giriş/çıkış Zod doğrulanır; yanıt Zod parse + z.infer ile dönülür.
  Ref: .cursor/rules/frontend/api.mdc, .cursor/rules/frontend/typescript.mdc
- **Query Key Factory:** Sihirli string yasak. Dosya: `src/features/[feature]/api/query-keys.ts`.
  Hiyerarşik: all → lists/list, details/detail; `as const`; key elle yazılmaz.
- **Custom Hook (Zorunlu):** `useQuery`/`useMutation` doğrudan bileşende yok; daima custom hook.
  Hook data, isLoading, error expose eder.
- **Abort:** queryFn `signal` API’ye aktarılır; API `params?: { signal?: AbortSignal }` kabul eder.
- **Pagination:** page (+ filtreler) query key’de; queryFn aynı parametreleri API’ye iletir.
- **Infinite:** `useInfiniteQuery`; response’ta nextPage; `getNextPageParam`, `initialPageParam: 1` zorunlu.
- **Mutation:** onSuccess’te ilgili query key invalidate; optimistik update kritik UX’te tercih.
- **Policy (SSOT):** staleTime/gcTime/retry varsayılanları docs/architecture-guide.md § TanStack Query default policy.
  Override: `src/providers/query-provider.tsx` veya feature hook içinde.
- **Hata:** QueryCache/MutationCache toast.
- **UI:** Bileşen sadece custom hook; loading’de skeleton.

## Yasaklar (Bans)

- Bileşen içinde HTTP / data fetching veya doğrudan useQuery/useMutation.
  Ref: .cursor/rules/frontend/api.mdc
- Query key’i manuel string yazmak.
- API yanıtını Zod/tip kontrolü olmadan kullanmak.
  Ref: .cursor/rules/frontend/typescript.mdc

## Always Do

```ts
export const postKeys = {
  all: ["posts"] as const,
  lists: () => [...postKeys.all, "list"] as const,
  list: (filters?: { category?: string }) => [...postKeys.lists(), filters] as const,
  details: () => [...postKeys.all, "detail"] as const,
  detail: (id: string) => [...postKeys.details(), id] as const,
};
```

```ts
export const useGetPosts = () =>
  useQuery({ queryKey: postKeys.list(), queryFn: ({ signal }) => getPosts({ signal }) });
```

```ts
export const useCreatePost = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: createPost,
    onSuccess: () => queryClient.invalidateQueries({ queryKey: postKeys.lists() }),
  });
};
```

```tsx
const { data: posts, isLoading } = useGetPosts();
if (isLoading) return <PostListSkeleton />;
return <div>{posts?.map((p) => <PostCard key={p.id} post={p} />)}</div>;
```

## Never Do

```ts
useQuery({ queryKey: ["posts", userId], queryFn: getPosts });
```

```tsx
function PostList() {
  const { data } = useQuery({ queryKey: ["posts"], queryFn: () => api.get("/posts") });
}
```
