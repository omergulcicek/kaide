---
description: "TanStack Query: key factory, custom hook, invalidation, Zod parse."
globs: "src/features/**/api/*.{ts,tsx},src/features/**/hooks/*.{ts,tsx},src/providers/query-provider.tsx"
alwaysApply: false
---

# TanStack Query

**Boundary:** Bileşen içinde HTTP/data fetching yasak → Ref: `api.mdc`. Veri sadece `hooks/` custom query hook’ları ile. Ref: `typescript.mdc` (Zod, tip politikası).

---

## Kısıtlamalar (Constraints)

- **API layer:** Bileşenler sadece hook ile veri; API giriş/çıkış Zod doğrulanır; yanıt Zod parse + z.infer ile dönülür.
- **Query Key Factory:** Sihirli string yasak. `src/features/[feature]/api/query-keys.ts`; hiyerarşik (all → lists/list, details/detail), `as const`; key elle yazılmaz.
- **Custom Hook (Zorunlu):** `useQuery`/`useMutation` doğrudan bileşende yok; daima custom hook. Hook data, isLoading, error expose eder.
- **Abort:** queryFn `signal` API’ye aktarılır; API `params?: { signal?: AbortSignal }` kabul eder.
- **Pagination:** page (+ filtreler) query key’de; queryFn aynı parametreleri API’ye iletir.
- **Infinite:** `useInfiniteQuery`; response’ta nextPage; `getNextPageParam`, `initialPageParam: 1` zorunlu.
- **Mutation:** onSuccess’te ilgili query key invalidate; `queryClient.invalidateQueries({ queryKey: postKeys.lists() })`. Optimistic update kritik UX’te tercih.
- **Global:** staleTime liste ~60s, detail ~5m; gcTime ~10m. Retry/delay `query-provider.tsx` merkezi; 4xx retry yok. Hata: QueryCache/MutationCache toast.
- **UI:** Bileşen sadece custom hook; loading’de skeleton.

---

## Yasaklar (Bans)

- Bileşen içinde HTTP / data fetching veya doğrudan useQuery/useMutation (Ref: api.mdc).
- Query key’i manuel string yazmak.
- API yanıtını Zod/tip kontrolü olmadan kullanmak (Ref: typescript.mdc).

---

## Always Do

```ts
// query-keys.ts
export const postKeys = {
  all: ["posts"] as const,
  lists: () => [...postKeys.all, "list"] as const,
  list: (filters?: { category?: string }) => [...postKeys.lists(), filters] as const,
  details: () => [...postKeys.all, "detail"] as const,
  detail: (id: string) => [...postKeys.details(), id] as const,
};
```

```ts
export const useGetPosts = () =>
  useQuery({ queryKey: postKeys.list(), queryFn: ({ signal }) => getPosts({ signal }) });
```

```ts
export const useCreatePost = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: createPost,
    onSuccess: () => queryClient.invalidateQueries({ queryKey: postKeys.lists() }),
  });
};
```

```tsx
const { data: posts, isLoading } = useGetPosts();
if (isLoading) return <PostListSkeleton />;
return <div>{posts?.map((p) => <PostCard key={p.id} post={p} />)}</div>;
```

---

## Never Do

```ts
useQuery({ queryKey: ["posts", userId], queryFn: getPosts });
```

```tsx
function PostList() {
  const { data } = useQuery({ queryKey: ["posts"], queryFn: () => api.get("/posts") });
}
```
