---
description: "HTTP katmanı. Client: axios + TanStack Query. Server: Next.js native fetch (cache/revalidate)."
globs: "src/lib/api.ts,src/features/**/api/*.{ts,tsx}"
alwaysApply: false
---

# API Layer

**Boundary:** Client → `axios` (`@/lib/api`). Server (RSC/SA/RH) cache/revalidate/tag → native `fetch`. Ref: `tanstack-query.mdc` (key/cache/invalidation), `typescript.mdc` (tip/any/return).

---

## Kısıtlamalar (Constraints)

- **Instance:** Tek `axios.create` → `src/lib/api.ts`. Başka yerde instance yok; tüm feature `@/lib/api` import.
- **Base URL:** Env'den; instance içinde. Feature içinde URL birleştirme yok.
- **Interceptor:** Request → auth, locale, tenant, trace. Response → unwrap, error → `AppError`, 401, refresh, retry (network/5xx). Token refresh: paralel 401 tek refresh; başarısız → global logout.
- **AppError (SSOT):** `{ code: string; message: string; status: number; details?: unknown }`. Tüm API hataları bu tip; raw axios error UI/query katmanına taşınmaz.
- **Yerleşim:** Endpoint fonksiyonları → `features/[feature]/api/`. Bileşen içinde HTTP/data fetching yasak; tek kaynak bu dosya.
- **Naming:** Fonksiyon → getUser, getUsers, createUser, updateUser, deleteUser. Dosya → `verb-entity.api.ts`.
- **Fonksiyon:** Tek endpoint, endpoint string sadece burada, axios instance, typed `Promise<ApiResponse<T>>`.
- **TanStack Query:** Query layer axios kullanmaz; sadece API fonksiyonu çağırır; endpoint bilmez. GET→query, POST/PUT/PATCH/DELETE→mutation.
- **Invalidation:** Mutation sonrası ilgili entity key; liste+detay birlikte; karar query layer’da.
- **Pagination:** Params: page, limit, sort, filters. Response: `{ items: T[]; total; page; limit }`. Parsing API katmanında.
- **Upload:** multipart/form-data; Content-Type interceptor dışında set edilmez.
- **Download:** responseType `blob`; dosya parsing API katmanında.
- **Types:** Response → `features/[feature]/types`. Zod varsa API dönüşünde parse. UI raw response işlemez; DTO/domain ayrımı.
- **Next.js server:** cache/revalidate/tag gereken yerde native fetch: `fetch(url, { cache, next: { revalidate, tags } })`.
- **Server Action:** Tüm input Zod ile validate; hata → anlamlı AppError/validation mesajı. RSC/Route Handler için de tercih.
- **Secret/DB:** Sadece server boundary içinde.

---

## Yasaklar (Bans)

- Feature içinde `axios.create`.
- Component içinde HTTP çağrısı.
- Query içinde endpoint string veya axios.
- Interceptor’ı feature’a koymak.
- Raw axios error taşımak; AppError’a maplenmeden dışarı vermek.
- Base URL’i feature içinde birleştirmek.
- `any` (Ref: typescript.mdc).
- Next.js server cache/revalidate/tag gereken yerde axios.
- Server Action’da Zod validation atlamak.

---

## Always Do

```ts
// API: tek instance, endpoint burada
import { api } from "@/lib/api";
export const getUsers = async (): Promise<ApiResponse<User[]>> => {
  const { data } = await api.get("/users");
  return data;
};
```

```ts
// Query: sadece API fonksiyonu
useQuery({ queryKey: userKeys.list(), queryFn: getUsers });
```

---

## Never Do

```ts
const api = axios.create({ baseURL: "/api" });
return api.get("/users/me");
```

```tsx
useEffect(() => { axios.get("/api/users/me"); }, []);
```

```ts
useQuery({ queryKey: ["user"], queryFn: () => axios.get("/users/me") });
```

```ts
// RSC/route handler, Next cache hedefleniyorsa axios kullanma
```
